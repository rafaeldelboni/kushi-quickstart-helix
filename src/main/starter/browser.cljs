(ns starter.browser
  (:require ["react-dom/client" :as rdom]
            [helix.core :refer [$ defnc]]
            [helix.dom :as d]
            [kushi.core :refer [add-font-face add-google-font!
                                add-system-font-stack defkeyframes inject! inject-stylesheet
                                sx]] ;; Require your apps shared classes and component namespaces
            [starter.badges :as badges]
            [starter.shared-styles])
  (:require-macros [helix.core]))

;; Injecting Stylesheets
;; .............................................................................................

;; Optional.
;; Using kushi.core/inject-stylesheet to inject a static css file.
;; This stylesheet might be a css reset file, or a third-party style library.
;; This is more of an edge case, as you would typically just do this with a <link> in your index.html.
;; However, if your project uses a clj file to generate the contents of your index's <head> at build time,
;;   it may be handy to use this during development to inject new stylesheets without restarting your build.
(inject-stylesheet {:rel "stylesheet"
                    :href "css/my-global-styles.css"})

;; Optional.
;; Using kushi.core/inject-stylesheet to load a google font.
;; The additional "preconnect" hints will improve Google Fonts performance.

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.gstatic.com"
                    :cross-origin "anonymous"})

(inject-stylesheet {:rel "preconnet"
                    :href "https://fonts.googleapis.com"})

(inject-stylesheet {:rel "stylesheet"
                    :href "https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap"})

;; If you want to add Google Fonts, you can also just use `kushi.core/add-google-fonts!`,
;; which will abstract the above pattern (3 separate calls) into one call.

(add-google-font! {:family "Inter"
                   :styles {:normal [400 700]
                            :italic [400 700]}})

;;`kushi.core/add-google-font!` accepts any number of args, each one a single map that
;; represents a font-family and associated weights & styles. You can as many different
;; families as you want in a single go (although be mindful of performance):

(add-google-font! {:family "Playfair Display"
                   :styles {:normal [400 700]
                            :italic [400 700]}}
                  {:family "Lato"
                   :styles {:normal [100 400]}}
                  {:family "Pacifico"
                   :styles {:normal [400]}})

;; Adding webfont resources
;; .............................................................................................

;; Optional.
;; Using kushi.core/add-font-face macro to load a local font.
;; This will add an @font-face block to the css code/file generated by kushi.
;; The location of the font file must be a path, relative the location of the generated css file.
;; You could also use a remote url to load a hosted font file.

(add-font-face {:font-family "FiraCodeRegular"
                :font-weight "333"
                :font-style "normal"
                :src ["url(../fonts/FiraCode-Regular.woff)"]})

;; Optional.
;; Using kushi.core/add-system-font-stack macro to add a system font stack.
;; The example below would write a total of 4 `@font-face` rules to your
;; kushi css file (`normal` and `italic` for both `300`("light") & `700`("bold")).
;; This system font stack is available as `sys` e.g. :ff--sys (which in css is `font-family: sys`)

(add-system-font-stack 300 700)

;; ;; Calling `add-system-font-stack` will add a total of 8 `@font-face`
;; ;; rules (300, 400, 500, and 700 - normal and italic for each).

(add-system-font-stack)

;; Defining animation keyframes
;; .............................................................................................

;; Using kushi.core/defkeyframes macro to define keyframes.
(defkeyframes y-axis-spinner
  [:0% {:transform "rotateY(0deg)"}]
  [:100% {:transform "rotateY(360deg)"}])

(defkeyframes x-axis-spinner
  [:0% {:transform "rotateX(0deg)"}]
  [:100% {:transform "rotateX(360deg)"}])

;; Styling component elements with sx
;; .............................................................................................

;; You can use kushi.core/sx to co-locate all your styles within your components.
;; Media queries, pseudo-classes, pseudo-elements, combo-selectors, and dynamic runtime values are all supported.

;; You can also incorporate your own shared classes (via the kushi.core/defclass macro),
;; as well as the useful defclasses that ship with Kushi.

;; kushi.core/sx is a macro that returns an attribute map.
;; This map contains:
;;   - a class property containing the correct auto-generated, hashed prefixed classnames.
;;   - If necessary, a style property containing the correct auto-generated css variable names.
;;   - All the other attributes you specify in your attributes map (supplied as an optional last arg to sx).
;;   - An optional data-ns attribute to help with browser-based debugging (see docs: "Using metadata").

;; Using a build hook for the :compile-finish stage (or similar), your css is written to a static file.

;; SOME NOTES ON SYNTAX:

;; You can passed a quoted symbol as the first arg to defclass if you want to give the generated
;; class a specific name.
;; (sx 'myfirstclass :c--red :fs--3rem)

;; A keyword starting with a "." represents a classname that will get attached to the element.
;; Typically you would use this for predefined classes created with defclass, but you can also use
;; it to attache arbritary classes to the element.
;; Kushi ships with a small handful of useful pre-defined defclasses.

;; You can apply classes conditionally like so:
;; (when my-binding :.my-class)
;; (if my-binding :.my-class :.my-other-class)

;; A keyword containing "--" represents a css prop and value pair (split on the "--").

;; Kushi shorthand notation is optionally available for the most commonly used css-props:
;;
;;     :c--red   => :color--red
;;     :ai--c    => :align-items--center
;;     :ai--e    => :align-items--end
;;     :ta--r    => :text-align--right
;;     :fs--18px => :font-size--18px
;;     :d--b     => :display--block
;;     :d--f     => :display--flex
;;     :bgs--50% => :background-size--50%
;;

;; A partial list of these is available here:
;; https://github.com/kushidesign/kushi#syntax

;; Standard CSS shorthand-values are written like this:
;;
;;     :b--1px:solid:#efefef
;;
;; The above is equivalent to `border: 1px solid #efefef`

;; CSS list-like values are written like this:
;;
;;     :ff--FiraCodeRegular|monospace|sans-serif
;;
;; The above is equivalent to `font-family: FiraCodeRegular, monospace, sans-serif`

;; Media queries, pseudo-classes, pseudo-elements, and combo selectors can be used like this:
;;
;;     (sx sm:c--red
;;         sm:hover:c--blue
;;         :>a:hover:c--gold
;;         :_a:hover:c--gold)

;;     In the example below, because "(" and ")" chars are not valid in keywords,
;;     the 2-element tuple syntax is required, with the prop being expressed as a string:
;;     (sx ["nth:child(2):c" :red])

;; You can use runtime variable values with the same tuple syntax.
;;     (sx [:c mycolor])

;;     You could also write this as:
;;     (sx {:style {:color mycolor})

;; You can use conditional logic to apply different values base on runtime variables.
;;     (sx [:c (if danger? :red :green)])

;; The tuple syntax is also necessary for css functions and string values.
;;
;;     Expressing a value as a css function:
;;     (sx [:transform '(translateY :-100px)])
;;     (sx {:style {:transform '(translateY :-100px)}})
;;
;;     When a string is desired, or necessary:
;;     (sx [:before:content "\"*\""])
;;     (sx {:style {:before:content "\"*\""}})

;; Now, some working code...

;; First, we define a subcomponent for the banner headline "layers"
;; This example component demonstrates the following:
;; 1) Using shared styles, the :.headline and :.twirl classes, which are defined in browser.shared-styles.
;; 2) Using kushi's shorthand syntax via tokenized keyword :animation-name--x-axis-spinner
;; 3) Using dynamic values for color and animation duration.

(defn headline-layer
  [color duration]
  (d/div
   {:style {:color color
            :animation-duration duration}
    :& (dissoc (sx 'headline-layer
                   :.headline
                   :.twirl
                   :animation-name--x-axis-spinner)
               :style)}
   "Kushi"))

;; Next, we define a subcomponent for the sub-header
;; This example component demonstrates the following:

;; 1) Using a quoted symbol to create your own selector name (instead of default auto-generated selector).
;; 2) Using kushi's shorthand syntax via tokenized keywords.
;; 3) Tokenized keyword with css "list" shorthand - :ff--FiraCodeRegular|monospace|sans-serif
;; 4) Using media queries - :sm:fs--14px
;; 5) Passing and attributes map (optional last arg to sx)

(defn twirling-subheader [s]
  (d/div
   {:& (sx 'kqs-twirling-subheader-wrapper
           :.twirl
           :.relative
           :ta--center
           :ff--FiraCodeRegular|monospace|sans-serif
           :fs--12px
           :sm:fs--14px
           :fw--800
           :c--white
           {:on-click #(prn "clicked!")})}
   s))

;; Main component.
(defnc main-view []
  (d/div
   {:& (sx 'main-app-wrapper
           :ff--sys)}
   (d/div
    {:& (sx :.flex-col-c
            :.absolute-fill
            :h--100%
            :ai--c
            :bgc--black)}

    ;; In this div we are using both tokenized keywords and a the 2-element tuple syntax.
    (d/div
     {:& (sx 'hero-wrapper
             :.flex-col-sb
             :ai--c
             :w--100%
             :h--200px
             :sm:h--375px
             :md:h--500px
             [:transform "translateY(calc(-100vh / 33))"])}

     ;; The color design tokens below are defined globally in the theme.cljc file,
     ;; which is specified in the :theme entry in your kushi.edn config file.
     (d/div
      (headline-layer "var(--howlite-blue)" :12s)
      (headline-layer "var(--canary-yellow)" :3s)
      (headline-layer "var(--deep-fuscsia)" :6s))
     (twirling-subheader "kushi × shadow-cljs quickstart")))
   (badges/links)))

;; Below is boilerplate code from https://github.com/shadow-cljs/quickstart-browser

;; start is called by init and after code reloading finishes
(defn ^:dev/after-load start []
  (doto (rdom/createRoot (js/document.getElementById "app"))
    (.render ($ main-view))))

(defn ^:export init []
  ;; init is called ONCE when the page loads
  ;; this is called in the index.html and must be exported
  ;; so it is available even in :advanced release builds
  (start))

;; this is called before any code is reloaded
(defn ^:dev/before-load stop [])

;; This will inject the same stylesheet that kushi writes to disk into your browser, during development builds.
;; You may not need or want to do this but if you are experiencing visual jankiness on reloads when devving, this can help.
(when ^boolean js/goog.DEBUG
  (inject!))
